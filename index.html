<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Urbanyx - Kindergartens</title>

    <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>    
 
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">        
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Georgian:wght@100..900&display=swap" rel="stylesheet">

    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'JetBrains Mono', monospace; color: #404040; }
        .map-container { display: flex; height: 100vh; flex-direction: row; }
        #map { flex: 1; order: 1; position: relative; }
        
        .search-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            width: 350px;
            display: none;
        }
        
        .search-container.visible { display: block; }
        
        #kindergartenSearch {
            width: 100%;
            padding: 12px 16px;
            font-family: 'Noto Sans Georgian', sans-serif;
            font-size: 14px;
            border: 2px solid #6c86cf;
            border-radius: 5px;
            background: white;
            box-shadow: 0 0 10px 0 #d0e8fd;
        }
        
        #kindergartenSearch:focus {
            outline: none;
            border-color: #810f7c;
            box-shadow: 0 0 10px 0 #e9d0fd;
        }
        
        .search-results {
            margin-top: 8px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }
        
        .search-result-item {
            padding: 12px 16px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            font-family: 'Noto Sans Georgian', sans-serif;
            font-size: 13px;
        }
        
        .search-result-item:hover { background: #f4f4f4; }
        .search-result-item:last-child { border-bottom: none; }
        
        .result-name {
            font-weight: bold;
            color: #6c86cf;
            margin-bottom: 4px;
        }
        
        .result-address {
            color: #666;
            font-size: 12px;
        }
        
        .result-phone {
            color: #999;
            font-size: 11px;
            margin-top: 2px;
        }
        
        .sidebar { order:0; width: 420px; overflow-y: auto; background: #f4f4f4; border-left: 1px solid #ddd; padding: 20px; }
        h1 { font-size: 5rem; text-align: center; background: transparent; margin: 0; color: rgba(255, 255, 255, 0.25); -webkit-text-stroke: 1px #6c86cf; }
        .section { margin-bottom: 18px; padding: 14px; background: #f4f4f4; border-radius: 5px; }
        .section h3 { font-size: 14px; margin-bottom: 10px; color: #333; }
        label { display: inline-block; margin: 10px; font-size: 13px; font-weight: bold; }
        select, input { width: 100%; padding: 8px; font-size: 13px; border: 1px solid #ddd; border-radius: 3px; font-family: inherit; }
        .toggle-group { display: flex; gap: 10px; justify-content: center; margin: 10px; }
        .toggle { flex: 1; padding: 10px; text-align: center; border-radius: 5px; cursor: pointer; transition: all 0.2s; font-size: 13px; }
        .toggle:hover { background: #f4f4f4; color: #810f7c; box-shadow: 4px 4px 0 #810f7c; transform: translate(-4px, -4px);}
        .toggle.active { background: rgb(21, 22, 27); color: #f4f4f4; box-shadow: 4px 4px 0 #810f7c; transform: translate(-4px, -4px);}
        .modal { font-family: JetBrains Mono, monospace; display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); }
        .modal-content { background: white; margin: 3% auto; padding: 25px; border-radius: 10px; max-width: 600px; max-height: 85vh; overflow-y: auto; } 
        .close { float: right; font-size: 28px; font-weight: bold; cursor: pointer; color: #aaa; }
        .close:hover { color: #000; }
        .question { margin: 15px 0; padding: 12px; background: #f4f4f4; border-left: 3px solid #6c86cf; }
        .question label { margin: 0 0 8px 0; }
        .radio-group label { display: flex; align-items: center; margin: 5px 0; font-weight: normal; }
        .radio-group input { width: auto; margin-right: 8px; }
        .results { background: #f4f4f4; padding: 15px; border-radius: 5px; margin-top: 15px; }
        .info-box { padding: 10px; background: #f4f4f4; border-radius: 3px; margin-bottom: 15px; font-size: 12px; line-height: 1.5; }
        .three-word-name { font-size: 16px; font-weight: bold; color: #6c86cf; margin: 5px 0; }
        .tab-buttons { display: flex; gap: 10px; justify-content: center; margin: 10px; }
        .tab-btn { font-family: JetBrains Mono, monospace; box-shadow: 0 0 20px 0 #d0e8fd; flex: 1; padding: 12px; background: #f4f4f4; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 13px; }
        .tab-btn:hover { background: #f4f4f4; box-shadow: 4px 4px 0 #810f7c; transform: translate(-4px, -4px); }
        .tab-btn.active { color: white; background: rgb(21, 22, 27); box-shadow: 4px 4px 0 #810f7c; transform: translate(-4px, -4px); }
        button.send { width: 100%; padding: 10px; background: #f4f4f4; color: #810f7c; border: none; border-radius: 5px; font-size: 14px; font-weight: bold; cursor: pointer; margin-top: 8px; }
        button.send:hover { background: #f4f4f4; box-shadow: 4px 4px 0 #810f7c; transform: translate(-4px, -4px) }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #timeResults { appearance: none; margin-left: 25px; display: inline-block; width: 15%; height: 50px; font-size: 14px; border: thin solid rgb(194, 194, 247); border-radius: 2px; box-shadow: 0 0 20px 0 #d0e8fd; text-align-last: center; padding-left: 5px; }
        .aggregate-stat { padding: 8px; margin: 5px 0; background: f4f4f4; border-radius: 3px; }
        .zaxis { display: block; position: absolute; bottom: 25px; left: 15px; z-index: 10; }
        
        .chart-container {
            background: #f4f4f4;
            padding: 12px;
            border-radius: 3px;
            margin-bottom: 12px;
        }
        
        .chart-container h4 {
            margin: 0 0 8px 0;
            font-size: 11px;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .chart-wrapper {
            position: relative;
            height: 75%;
            margin-bottom: 5px;
        }
        
        .chart-wrapper.small { height: 50%; }
        .chart-wrapper.tiny { height: 50%; }
        
        .dropdown-header {
            background: #f4f4f4;
            padding: 12px 14px;
            cursor: pointer;
            border-radius: 3px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 13px;
            transition: background 0.2s;
            border-radius: 5px;
            border: 1px solid #6c86cf;
        }
        
        .dropdown-header:hover {
            background: #d0e8fd;
        }
        
        .dropdown-arrow {
            transition: transform 0.3s;
            font-size: 18px;
        }
        
        .dropdown-arrow.open {
            transform: rotate(180deg);
        }
        
        .dropdown-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .dropdown-content.open {
            max-height: 2000px;
            transition: max-height 0.5s ease-in;
        }
        
        .kindergarten-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .kindergarten-item {
            padding: 10px;
            background: #f9f9f9;
            border-radius: 3px;
            margin-bottom: 8px;
            font-size: 12px;
            border-left: 3px solid #810f7c;
        }
        
        .kindergarten-item.selected {
            background-color: #f9d2fb;
            border-left-color: #e63946;
        }

        .kindergarten-item:hover {
            background-color: #f768a14c; /* normal hover effect */
        }

        .kindergarten-item h4 {
            color: #810f7c;
            margin: 0 0 6px 0;
            font-size: 13px;
        }
        
        .kindergarten-item p {
            margin: 3px 0;
            color: #666;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(213, 62, 79, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(213, 62, 79, 0); }
            100% { box-shadow: 0 0 0 30px rgba(213, 62, 79, 0); }
        }
        
        .pulsating-dot {
            width: 20px;
            height: 20px;
            background: #e7298a;
            border-radius: 50%;
            animation: pulse 4s infinite;
        }

        /* Remove the default tip and set background */
        /* Remove the default tip */

        #routePopup {
            position: absolute;
            top: 10px;               /* same vertical alignment as nav buttons */
            right: 50px;             /* leave space for zoom buttons */
            background: rgba(58, 111, 161, 0.193);
            color: #fff;
            backdrop-filter: blur(2px);
            padding: 15px;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            line-height: 1.25rem;
            box-shadow: 0 0 30px 0 rgba(255, 255, 255, 0.25);
            max-width: 300px;
            z-index: 999;            /* stay above the map layers */
        }

        .accident-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .accident-item {
            padding: 10px;
            background: #fff5f5;
            border-radius: 3px;
            margin-bottom: 8px;
            font-size: 12px;
            border-left: 3px solid #e63946;
        }

        .accident-item h4 {
            color: #e63946;
            margin: 0 0 6px 0;
            font-size: 13px;
        }

        .accident-item p {
            margin: 3px 0;
            color: #666;
        }
        
        @media (max-width: 768px) {
            .map-container { flex-direction: column; }
            .sidebar { width: 100%; border-left: none; border-top: 1px solid #ddd; height: 35vh; }
            #map { height: 65vh; }
            .search-container { width: calc(100% - 40px); }
        }
    </style>
</head>
<body>
    <div id="modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 style="text-align: center; margin-bottom: 15px;">კითხვარი</h2>
            <div id="cellInfo" class="info-box"></div>
            
            <form id="surveyForm">
                <div class="question">
                    <label>1. რა ასაკის ხართ?</label>
                    <select name="age" required>
                        <option value="">აირჩიეთ...</option>
                        <option value="18-25">18-25</option>
                        <option value="26-35">26-35</option>
                        <option value="36-45">36-45</option>
                        <option value="46-55">46-55</option>
                        <option value="56+">56+</option>
                    </select>
                </div>
                <div class="question">
                    <label>2. სქესი:</label>
                    <div class="radio-group">
                        <label><input type="radio" name="gender" value="male" required> მამრობითი</label>
                        <label><input type="radio" name="gender" value="female"> მდედრობითი</label>
                        <label><input type="radio" name="gender" value="other"> სხვა</label>
                    </div>
                </div>
                <div class="question">
                    <label>3. რომელ პარტიას მისცემთ ხმას?</label>
                    <select name="vote" required>
                        <option value="">აირჩიეთ...</option>
                        <option value="qocebi">ქართული ოცნება</option>
                        <option value="lelo">ლელო</option>
                        <option value="gakharia">გახარია</option>
                        <option value="boycott">ბოიკოტი</option>
                        <option value="undecided">გადაუწყვეტელი</option>
                    </select>
                </div>
                <div class="question">
                    <label>4. ეკონომიკის შეფასება:</label>
                    <select name="economy" required>
                        <option value="">აირჩიეთ...</option>
                        <option value="very_good">ძალიან კარგი</option>
                        <option value="good">კარგი</option>
                        <option value="neutral">საშუალო</option>
                        <option value="bad">ცუდი</option>
                        <option value="very_bad">ძალიან ცუდი</option>
                    </select>
                </div>
                <div class="question">
                    <label>5. მთავარი პრიორიტეტი:</label>
                    <select name="priority" required>
                        <option value="">აირჩიეთ...</option>
                        <option value="economy">ეკონომიკა</option>
                        <option value="democracy">დემოკრატია</option>
                        <option value="eu">ევროინტეგრაცია</option>
                        <option value="security">უსაფრთხოება</option>
                        <option value="education">განათლება</option>
                    </select>
                </div>
                <button class="send" type="submit">გაგზავნა</button>
            </form>
        </div>
    </div>

    <div class="map-container">
        <div id="map">
            <div class="search-container">
                <input type="text" id="kindergartenSearch" placeholder="ძებნა: ბაგა-ბაღის სახელი ან მისამართი..." />
                <div class="search-results" id="searchResults"></div>
            </div>
            
            <footer>
                <div class="zaxis">
                    <a href="https://zaxis.ge"><img src="https://raw.githubusercontent.com/axis-Z/urbanyxv1/refs/heads/main/img/white-transparent-background.png" alt="" width="75"></a>
                </div>
            </footer>
        </div>
        
        <div class="sidebar">
            <div class="title"><h1>URBANYX</h1></div>

            <div class="tab-buttons">
                <button class="tab-btn active" onclick="switchTab('survey')">კითხვარი</button>
                <button class="tab-btn" onclick="switchTab('results')">შედეგები</button>
            </div>
            
            <div id="surveyTab" class="tab-content active">
                <div class="section">
                    <h3>ინსტრუქცია</h3>
                    <p style="font-size: 12px; line-height: 1.6;">
                        • დააკლიკე 500m x 500m grid უჯრედზე<br>
                        • თითოეულ უჯრედს აქვს უნიკალური სახელი<br>
                        • შეავსე კითხვარი<br>
                        • პასუხები ინახება Google Sheets-ში
                    </p>
                </div>
            </div>
            
            <div id="resultsTab" class="tab-content">
                <div class="section">
                    <h3>ანალიზის პარამეტრები</h3>
                    <p style="font-size: 12px; margin-bottom: 10px;">
                        დააკლიკე რუკაზე სასურველ წერტილზე იზოქრონის შესაქმნელად.
                    </p>
                    <label>გადაადგილების დრო (წუთი)</label>
                    <select id="timeResults">
                        <option value="10">10</option>
                        <option value="15" selected>15</option>
                        <option value="20">20</option>
                        <option value="25">25</option>
                        <option value="30">30</option>
                    </select>
                    
                    <label style="margin-top: 12px;">გადაადგილების ფორმა</label>
                    <div class="toggle-group">
                        <div class="toggle active" data-mode="walking" onclick="setResultsMode('walking')">ფეხით<br><span class="material-symbols-outlined">footprint</span></div>
                        <div class="toggle" data-mode="cycling" onclick="setResultsMode('cycling')">ველო<br><span class="material-symbols-outlined">directions_bike</span></div>
                    </div>
                </div>
                
                <div id="aggregateResults" class="results" style="display: none;">
                    <div class="dropdown-header" onclick="toggleDropdown('resultsDropdown')">
                        <span>აგრეგირებული შედეგები</span>
                        <span class="dropdown-arrow" id="resultsDropdownArrow">▼</span>
                    </div>
                    <div class="dropdown-content" id="resultsDropdown">
                        <div id="aggregateContent"></div>
                    </div>
                </div>
                
                <div id="kindergartenResults" class="results" style="display: none;">
                    <div class="dropdown-header" onclick="toggleDropdown('kindergartenDropdown')">
                        <span>ბაგა-ბაღები არეალში (<span id="kindergartenCount">0</span>)</span>
                        <span class="dropdown-arrow" id="kindergartenDropdownArrow">▼</span>
                    </div>
                    <div class="dropdown-content" id="kindergartenDropdown">
                        <div class="kindergarten-list" id="kindergartenList"></div>
                    </div>
                </div>

                <div id="accidentResults" class="results" style="display: none;">
                    <div class="dropdown-header" onclick="toggleDropdown('accidentDropdown')">
                        <span>ავარიები არეალში (<span id="accidentCount">0</span>)</span>
                        <span class="dropdown-arrow" id="accidentDropdownArrow">▼</span>
                    </div>
                    <div class="dropdown-content" id="accidentDropdown">
                        <div class="chart-container">
                            <h4>ავარიების კატეგორიები</h4>
                            <div class="chart-wrapper tiny">
                                <canvas id="accidentCategoryChart"></canvas>
                            </div>
                        </div>
                        <div class="accident-list" id="accidentList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwRShukywhUdgLnCoptNE5JCVOwthMVmj42_QpAtnDGyjzhTZIFsh9iBKADW6qWelWY/exec';
        
        const GEORGIAN_WORDS = ['მზე', 'მთა', 'წყალი', 'ხე', 'ყვავილი', 'ქარი', 'ღრუბელი', 'მდინარე', 'ტბა', 'ველი', 'ტყე', 'ქვა', 'ცა', 'მიწა', 'ვარსკვლავი', 'მთვარე', 'ნისლი', 'თოვლი', 'წვიმა', 'რადიო', 'წიგნი', 'სახლი', 'გზა', 'ხიდი', 'კარი', 'ფანჯარა', 'ბაღი', 'ეზო', 'ქუჩა', 'მოედანი', 'ციხე', 'ეკლესია', 'მუზეუმი', 'პარკი', 'ბულვარი', 'სკვერი', 'ფონტანი', 'ძეგლი', 'თეატრი', 'კინო', 'ყურძენი', 'ვაშლი', 'მსხალი', 'ატამი', 'ფორთოხალი', 'ლიმონი', 'ჟოლო', 'კივი', 'ბანანი', 'საზამთრო'];
        
        function toggleDropdown(id) {
            const content = document.getElementById(id);
            const arrow = document.getElementById(id + 'Arrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        let carAccidentData = null;
        let currentSelectedKindergarten = null;
        let currentSelectedKindergartenName = null;
        let currentIsochronePolygon = null;
        let allKindergartenFeatures = [];

        mapboxgl.accessToken = "pk.eyJ1Ijoiam9yam9uZTkwIiwiYSI6ImNrZ3R6M2FvdTBwbmwycXBibGRqM2w2enYifQ.BxjvFSGqefuC9yFCrXC-nQ";
        
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/jorjone90/cmd1cg82i000101s61qwaca16',
            center: [44.800, 41.7350],
            zoom: 12,
            attributionControl: true,
            preserveDrawingBuffer: true
        });

        map.addControl(new mapboxgl.NavigationControl());

        let userLocation = null;

        const geolocate = new mapboxgl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 },
            trackUserLocation: true,
            showUserHeading: true,
            fitBoundsOptions: { maxZoom: 15 }
        });

        map.addControl(geolocate);

        geolocate.on('geolocate', (e) => {
            userLocation = [e.coords.longitude, e.coords.latitude];
            console.log('User location updated:', userLocation);
        });
        
        let kindergartenData = null;
        let marker = null;
        let surveyDataGeoJSON = { type: 'FeatureCollection', features: [] };
        let currentFeature = null;
        let currentTab = 'survey';
        let resultsMode = 'walking';
        let chartInstances = {};
        
        const ORIGIN_LNG = 41.0, ORIGIN_LAT = 41.0, GRID_EXTENT_LNG = 47.0, GRID_EXTENT_LAT = 44.0, GRID_SIZE_METERS = 500;
        
        function metersToDegrees(lat, meters) {
            return {
                latDeg: meters / 111320,
                lonDeg: meters / (111320 * Math.cos(lat * Math.PI / 180))
            };
        }

        const avgLat = (ORIGIN_LAT + GRID_EXTENT_LAT) / 2;
        const { latDeg: GRID_SIZE_LAT, lonDeg: GRID_SIZE_LNG } = metersToDegrees(avgLat, GRID_SIZE_METERS);

        function generateThreeWordName(cellId) {
            const [x, y] = cellId.split(',').map(Number);
            const hash = Math.abs((x * 73856093) ^ (y * 19349663));
            return `${GEORGIAN_WORDS[hash % GEORGIAN_WORDS.length]}.${GEORGIAN_WORDS[Math.floor(hash / GEORGIAN_WORDS.length) % GEORGIAN_WORDS.length]}.${GEORGIAN_WORDS[Math.floor(hash / (GEORGIAN_WORDS.length * GEORGIAN_WORDS.length)) % GEORGIAN_WORDS.length]}`;
        }

        function getCellId(lng, lat) {
            return `${Math.floor((lng - ORIGIN_LNG) / GRID_SIZE_LNG)},${Math.floor((lat - ORIGIN_LAT) / GRID_SIZE_LAT)}`;
        }

        function getCellBounds(cellId) {
            const [x, y] = cellId.split(',').map(Number);
            const minLng = ORIGIN_LNG + x * GRID_SIZE_LNG;
            const minLat = ORIGIN_LAT + y * GRID_SIZE_LAT;
            return [[minLng, minLat], [minLng + GRID_SIZE_LNG, minLat], [minLng + GRID_SIZE_LNG, minLat + GRID_SIZE_LAT], [minLng, minLat + GRID_SIZE_LAT], [minLng, minLat]];
        }

        function getCellCenter(cellId) {
            const bounds = getCellBounds(cellId);
            return [(bounds[0][0] + bounds[2][0]) / 2, (bounds[0][1] + bounds[2][1]) / 2];
        }

        function buildFixedGrid() {
            const features = [];
            for (let lng = ORIGIN_LNG; lng < GRID_EXTENT_LNG; lng += GRID_SIZE_LNG) {
                for (let lat = ORIGIN_LAT; lat < GRID_EXTENT_LAT; lat += GRID_SIZE_LAT) {
                    const cellId = getCellId(lng, lat);
                    features.push({
                        type: 'Feature',
                        geometry: { type: 'Polygon', coordinates: [getCellBounds(cellId)] },
                        properties: { cellId, count: 0 }
                    });
                }
            }
            return { type: 'FeatureCollection', features };
        }

        let fixedGrid = buildFixedGrid();
        
        async function loadDataFromSheets() {
            try {
                const response = await fetch(APPS_SCRIPT_URL);
                const data = await response.json();
                
                if (data.status === 'success' && data.rows) {
                    const gridMap = {};
                    
                    data.rows.forEach(row => {
                        const gridName = row[1];
                        const cellId = row[2];
                        const lat = parseFloat(row[3]);
                        const lng = parseFloat(row[4]);
                        
                        if (!gridMap[gridName]) {
                            gridMap[gridName] = {
                                type: 'Feature',
                                geometry: { type: 'Point', coordinates: [lng, lat] },
                                properties: { gridName, cellId, responses: [] }
                            };
                        }
                        
                        gridMap[gridName].properties.responses.push({
                            timestamp: row[0],
                            age: row[5],
                            gender: row[6],
                            vote: row[7],
                            economy: row[8],
                            priority: row[9]
                        });
                    });
                    
                    surveyDataGeoJSON.features = Object.values(gridMap);
                    
                    if (map.isStyleLoaded() && map.getSource('survey-data')) {
                        map.getSource('survey-data').setData(surveyDataGeoJSON);
                    }
                    
                    updateGridLayer();
                    updateDataStatus();
                }
            } catch (err) {
                console.error('Failed to load data:', err);
            }
        }

        // ============================================
        // 2. ADD THIS FUNCTION TO LOAD ACCIDENT DATA
        // ============================================
        async function loadCarAccidentData() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/axis-Z/urbanyxv1/main/data/car_crashes.geojson');
                if (!response.ok) throw new Error('Network response was not ok');
                carAccidentData = await response.json();
                
                // Map crash_type to Georgian categories
                carAccidentData.features = carAccidentData.features.map(feature => {
                    const crashType = feature.properties.crash_type;
                    let category = 'მსუბუქი'; // default to soft
                    
                    if (crashType === 'injury') {
                        category = 'მძიმე';
                    } else if (crashType === 'soft') {
                        category = 'მსუბუქი';
                    }
                    
                    return {
                        ...feature,
                        properties: {
                            ...feature.properties,
                            category: category
                        }
                    };
                });
                
                if (map.getSource('car-accidents')) {
                    map.getSource('car-accidents').setData(carAccidentData);
                }
                
                console.log('Loaded', carAccidentData.features.length, 'car accidents');
            } catch (err) {
                console.error('Failed to load car accident data:', err);
            }
        }

        // ============================================
        // 3. ADD THESE FUNCTIONS FOR ACCIDENT FILTERING
        // ============================================
        function filterAccidentsByIsochrone(isochronePolygon) {
            if (!carAccidentData || !carAccidentData.features) return [];
            
            const accidentsInIsochrone = [];
            carAccidentData.features.forEach(feature => {
                const point = turf.point(feature.geometry.coordinates);
                try {
                    if (turf.booleanPointInPolygon(point, isochronePolygon)) {
                        accidentsInIsochrone.push(feature);
                    }
                } catch (err) {
                    console.error('Error checking accident:', err);
                }
            });
            
            return accidentsInIsochrone;
        }

        function updateAccidentsLayer(isochronePolygon) {
            const accidentsInIsochrone = filterAccidentsByIsochrone(isochronePolygon);
            const geoJSON = { type: 'FeatureCollection', features: accidentsInIsochrone };
            
            if (map.getSource('isochrone-accidents')) {
                map.getSource('isochrone-accidents').setData(geoJSON);
            } else {
                map.addSource('isochrone-accidents', { type: 'geojson', data: geoJSON });
                map.addLayer({
                    id: 'isochrone-accidents-layer',
                    type: 'circle',
                    source: 'isochrone-accidents',
                    paint: {
                        'circle-radius': 1.75,
                        'circle-color': [
                            'match',
                            ['get', 'category'],
                            'მძიმე', '#a50f15',
                            'მსუბუქი', '#225ea8',
                            '#f77f00' // default
                        ],
                        'circle-opacity': 0.8,
                        'circle-stroke-width': .01,
                        'circle-stroke-color': '#ffffff'
                    }
                });
            }
            
            displayAccidentList(accidentsInIsochrone);
            document.getElementById('accidentResults').style.display = 'block';
        }

        function displayAccidentList(accidents) {
            const list = document.getElementById('accidentList');
            const count = document.getElementById('accidentCount');
            count.textContent = accidents.length;
            
            if (accidents.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">ავარიები არ მოიძებნა</p>';
                return;
            }
            
            // Count by category
            const categories = { 'მძიმე': 0, 'მსუბუქი': 0 };
            accidents.forEach(f => {
                const cat = f.properties.category || 'მსუბუქი';
                categories[cat] = (categories[cat] || 0) + 1;
            });
            
            // Ensure chartInstances object exists
if (!window.chartInstances) window.chartInstances = {};

// Small timeout to ensure canvas exists in DOM
setTimeout(() => {
    const ctx = document.getElementById('accidentCategoryChart')?.getContext('2d');
    if (!ctx) return;

    // Destroy existing chart if present
    if (chartInstances.accidents) {
        chartInstances.accidents.destroy();
    }

    // Reuse same chartConfig as genderChart
    const chartConfig = {
        responsive: true,
        maintainAspectRatio: true,
        cutout: '75%',
        plugins: {
            legend: {
                display: true,
                position: 'bottom',
                labels: { font: { size: 10 } }
            },
            tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                padding: 8,
                titleFont: { size: 11 },
                bodyFont: { size: 10 }
            }
        }
    };

    chartInstances.accidents = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: ['მძიმე', 'მსუბუქი'],
            datasets: [{
                data: [
                    categories['მძიმე'] || 0, 
                    categories['მსუბუქი'] || 0
                ],
                backgroundColor: ['#a50f15', '#225ea8'],
                borderWidth: 0
            }]
        },
        options: chartConfig
    });

}, 100);
            
        }

        /**
         * Show route between two points
         * @param {Array} from - [lng, lat]
         * @param {Array} to - [lng, lat]
         * @param {string} mode - 'walking' or 'cycling'
         * @param {boolean} permanent - true = click route, false = hover route
         */

        let tempRoutePopup = null; // global variable to track temporary popup

        // --- MAIN ROUTE FUNCTION ---
        async function showRoute(from, to, mode, permanent = false) {
            const routeId = permanent ? 'route-line' : 'temp-route-line';
            const sourceId = permanent ? 'route-source' : 'temp-route';

            // Remove existing temp route if any
            if (!permanent) {
                if (map.getLayer(routeId)) map.removeLayer(routeId);
                if (map.getSource(sourceId)) map.removeSource(sourceId);
                if (tempRoutePopup) {
                    tempRoutePopup.remove();
                    tempRoutePopup = null;
                }
            }

            // Fetch route from Mapbox Directions API with maxspeed annotations
            const response = await fetch(
                `https://api.mapbox.com/directions/v5/mapbox/${mode}/${from[0]},${from[1]};${to[0]},${to[1]}?geometries=geojson&annotations=maxspeed&overview=full&access_token=${mapboxgl.accessToken}`
            );
            const data = await response.json();

            const route = data.routes[0].geometry;
            const distance = data.routes[0].distance; // meters
            const duration = data.routes[0].duration; // seconds

            // Extract speed limit annotations (if available)
            const maxspeeds = data.routes[0].legs[0].annotation?.maxspeed || [];
            const numericSpeeds = maxspeeds
                .map(s => {
                    if (s && s.speed) return s.speed; // value in km/h
                    return null;
                })
                .filter(v => v !== null);

            const avgCarSpeed =
                numericSpeeds.length > 0
                    ? numericSpeeds.reduce((a, b) => a + b, 0) / numericSpeeds.length
                    : null;

            // Add route to map
            map.addSource(sourceId, {
                type: 'geojson',
                data: { type: 'Feature', geometry: route }
            });

            map.addLayer({
                id: routeId,
                type: 'line',
                source: sourceId,
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: {
                    'line-color': '#80cdc1',
                    'line-width': permanent ? 4 : 2,
                    'line-opacity': permanent ? 1 : 0
                }
            });

            // Smooth fade-in
            let opacity = 0;
            const fadeIn = () => {
                opacity += 0.05;
                if (opacity >= 1) opacity = 1;
                map.setPaintProperty(routeId, 'line-opacity', opacity);
                if (opacity < 1) requestAnimationFrame(fadeIn);
            };
            fadeIn();

            // Fit map to route
            const routeBounds = route.coordinates.reduce(
                (bounds, coord) => bounds.extend(coord),
                new mapboxgl.LngLatBounds(route.coordinates[0], route.coordinates[0])
            );
            map.fitBounds(routeBounds, {
                padding: { top: 0, bottom: 0, left: 0, right: 0 },
                duration: 1000,
                bearing: 0,
                pitch: 60
            });
            
            // Determine speed label text and style

            // --- Count crash types within 20m buffer ---
            let lightCrashes = 0;
            let severeCrashes = 0;
            if (typeof carAccidentData !== 'undefined' && carAccidentData.features) {
                const routeFeature = { type: 'Feature', geometry: route };
                const buffer = turf.buffer(routeFeature, 0.02, { units: 'kilometers' }); // 20m
                carAccidentData.features.forEach(f => {
                    if (turf.booleanPointInPolygon(f, buffer)) {
                        if (f.properties.category === 'მძიმე') severeCrashes++;
                        else lightCrashes++;
                    }
                });
            }

            // --- CRASH PROBABILITIES ADJUSTED BY SPEED ---
            const routeKm = distance / 1000 || 1;
            let severeCrashProb = severeCrashes / routeKm;
            let lightCrashProb = lightCrashes / routeKm;

            if (avgCarSpeed !== null) {
                const speedFactor = Math.pow(avgCarSpeed / 30, 1.2); // scale probability by speed
                severeCrashProb *= speedFactor;
                lightCrashProb *= speedFactor;
            }

            // --- Determine speed label text and style ---
            const modeTranslation = { walking: 'ფეხით', driving: 'მანქანით', cycling: 'ველოსიპედით' };
            const translatedMode = modeTranslation[mode] || mode;

            let speedStyle = '';
            let speedMessage = '';
            if (avgCarSpeed !== null) {
                const speedText = `${avgCarSpeed.toFixed(1)} კმ/სთ`;
                if (avgCarSpeed <= 30) {
                    speedStyle = 'background-color: rgba(0,128,0,0.8); color:#fff; padding:2px 4px; border-radius:4px;';
                    speedMessage = `ამ მონაკვეთზე, მძღოლები, შედარებით ნელა - <span style="background-color: rgba(0,128,0,0.8); color:#fff; padding:2px 4px; border-radius:4px;">${speedText}</span> მოძრაობენ, რაც ნაკლებად საფრთხის შემცველია ბავშვისთვის ${translatedMode} გადაადგილებისას.`;
                } else if (avgCarSpeed <= 50) {
                    speedStyle = 'background-color: rgba(255,165,0,0.8); color:#fff; padding:2px 4px; border-radius:4px;';
                    speedMessage = `აღნიშნულ მარშრუტზე, მძღოლები, საშუალოდ <span style="background-color: rgba(255,165,0,0.8); color:#fff; padding:2px 4px; border-radius:4px;">${speedText} სიჩქარით</span> გადაადგილდებიან. არსებობს მომეტებული საფრთხე აქ ბავშვთან ერთად ${translatedMode} გადაადგილებისას.`;
                } else {
                    speedStyle = 'background-color: rgba(255,0,0,0.8); color:#fff; padding:2px 4px; border-radius:4px;';
                    speedMessage = `ეს მონაკვეთი გამოირჩევა განსაკუთრებით სახიფათო საავტომობილო მოძრაობითა და მაღალი სიჩქარით <span style="background-color: rgba(255,0,0,0.8); color:#fff; padding:2px 4px; border-radius:4px;">${speedText}</span> შეადგენს. ეს გარემოება არასახარბიელო პირობებს ქმნის ბავშვთან ერთად ${translatedMode} გადაადგილებისას.`;
                }
            } else {
                speedMessage = '<span style="color:gray;">სიჩქარის მონაცემი მიუწვდომელია</span>';
            }

            // --- Generate crash messages ---
            const getProbColor = (prob) => {
                if (prob <= 0.1) return 'rgba(0,128,0,0.8)';
                else if (prob <= 0.3) return 'rgba(255,165,0,0.8)';
                else return 'rgba(255,0,0,0.8)';
            };

            let severeCrashMessage;
            if (severeCrashes === 0) {
                severeCrashMessage = `ამ არეალში, გასულ წელს, მძიმე შემთხვევები, სხეულის დაზიანებით, არ დაფიქსირებულა.`;
            } else if (severeCrashProb === 0) {
                severeCrashMessage = `<span style="color:gray;">მონაცემები არასაკმარისია მძიმე შემთხვევების ალბათობის შეფასებისთვის.</span>`;
            } else {
                severeCrashMessage = `ამ არეალში, გასულ წელს, <span style="background-color: rgba(255,0,0,0.8); color:#fff; padding:2px 4px; border-radius:4px;"><b>${severeCrashes}</b></span> შემთხვევა დაფიქსირდა, სხეულის დაზიანებით. მძიმე შემთხვევების განმეორების ალბათობა <span style="background-color: ${getProbColor(severeCrashProb)}; color:#fff; padding:2px 4px; border-radius:4px;">${severeCrashProb.toFixed(2)}</span> შეადგენს ყოველ ერთ კილომეტრზე.`;
            }

            //const severeCrashMessage = `ამ არეალში გასულ წელს, <span style="background-color: rgba(255,0,0,0.8); color:#fff; padding:2px 4px; border-radius:4px;"<b>${severeCrashes}</b></span> შემთხვევა დაფიქსირდა სხეულის დაზიანებით. მათი განმეორების ალბათობა კი <span style="background-color: ${getProbColor(severeCrashProb)}; color:#fff; padding:2px 4px; border-radius:4px;">${severeCrashProb.toFixed(2)}</span> შემთხვევას შეადგენს ყოველ ერთ კილომეტრიან მონაკვეთზე.`;
            //const lightCrashMessage = `მსუბუქი შემთხვევების ალბათობა: <span style="background-color: ${getProbColor(lightCrashProb)}; color:#fff; padding:2px 4px; border-radius:4px;">${lightCrashProb.toFixed(2)} / კმ</span>`;

            // --- Add popup ---
            if (!permanent) {
                const midpoint = route.coordinates[Math.floor(route.coordinates.length / 2)];
                const distanceKm = (distance / 1000).toFixed(1);
                const durationMin = Math.round(duration / 60);

                // Create popup element once
                let routePopupDiv = document.getElementById('routePopup');
                if (!routePopupDiv) {
                    routePopupDiv = document.createElement('div');
                    routePopupDiv.id = 'routePopup';
                    routePopupDiv.style.display = 'block';
                    routePopupDiv.style.position = 'absolute';
                    routePopupDiv.style.top = '10px';
                    routePopupDiv.style.right = '50px';
                    routePopupDiv.style.background = 'rgba(58, 111, 161, 0.193)';
                    routePopupDiv.style.color = '#fff';
                    routePopupDiv.style.backdropFilter = 'blur(2px)';
                    routePopupDiv.style.padding = '15px';
                    routePopupDiv.style.borderRadius = '8px';
                    routePopupDiv.style.fontFamily = "'JetBrains Mono', monospace";
                    routePopupDiv.style.lineHeight = '1.25rem';
                    routePopupDiv.style.boxShadow = '0 0 30px 0 rgba(255, 255, 255, 0.25)';
                    routePopupDiv.style.maxWidth = '300px';
                    routePopupDiv.style.zIndex = '999';
                    map.getContainer().appendChild(routePopupDiv);
                } else {
                    routePopupDiv.style.display = 'block';
                }

                // --- Update content with collapsible section ---
                routePopupDiv.innerHTML = `
                    <div id="routePopupContent">
                        <div>
                            ამ მანძილის <b>(${distanceKm} კმ)</b> ${translatedMode} გავლას, 
                            <b>${durationMin}</b> წთ დასჭირდება. ${speedMessage}
                        </div>
                        <div>${severeCrashMessage}</div>
                        <div id="elevationContainer" style="margin-top:10px; display:none;">
                            <canvas id="elevationChart" height="100"></canvas>
                        </div>
                    </div>

                    <div style="display:flex; justify-content:center; margin-top:8px;">
                        <button id="routePopupToggle" style="
                            background: rgba(0,0,0,0);
                            color: #fff;
                            border: none;
                            border-radius: 3px;
                            padding: 2px 6px;
                            cursor: pointer;
                            font-size: 12px;
                        ">▲</button>
                    </div>
                `;

                // --- Toggle Functionality ---
                const toggleBtn = document.getElementById('routePopupToggle');
                const popupContent = document.getElementById('routePopupContent');
                toggleBtn.onclick = () => {
                    if (popupContent.style.display === 'none') {
                        popupContent.style.display = 'block';
                        toggleBtn.textContent = '▲';
                    } else {
                        popupContent.style.display = 'none';
                        toggleBtn.textContent = '▼';
                    }
                };

            }
        }


        // --- ROUTE FROM USER TO SELECTED POINT ---
        function showRouteToSelected(destinationCoords, mode = 'walking', permanent = false) {
            // If userLocation already known from geolocate control
            if (userLocation) {
                showRoute(userLocation, destinationCoords, mode, permanent);
                return;
            }

            // Otherwise fallback to browser geolocation
            if (!navigator.geolocation) {
                alert("Geolocation is not supported by your browser");
                return;
            }

            navigator.geolocation.getCurrentPosition(
                position => {
                    const userCoords = [position.coords.longitude, position.coords.latitude];
                    userLocation = userCoords; // Save for reuse
                    showRoute(userCoords, destinationCoords, mode, permanent);
                },
                error => {
                    console.warn("Geolocation failed:", error.message);
                    alert("Couldn't get your location.");
                },
                { enableHighAccuracy: true, timeout: 5000 }
            );
        }

        async function loadKindergartenData() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/gkankia/kindergarten-tbilisi/main/kindergartens_tbilisi_1.geojson');
                if (!response.ok) throw new Error('Network response was not ok');
                kindergartenData = await response.json();
                allKindergartenFeatures = kindergartenData.features.slice();
                if (map.getSource('kindergartens')) {
                    map.getSource('kindergartens').setData(kindergartenData);
                }
            } catch (err) {
                console.error('Failed to load kindergarten data:', err);
            }
        }
        
        const searchInput = document.getElementById('kindergartenSearch');
        const searchResults = document.getElementById('searchResults');
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim().toLowerCase();
            if (query.length < 1 || !kindergartenData) {
                searchResults.style.display = 'none';
                return;
            }

            const bounds = map.getBounds();
            const minLng = bounds.getWest();
            const maxLng = bounds.getEast();
            const minLat = bounds.getSouth();
            const maxLat = bounds.getNorth();

            const matches = kindergartenData.features.filter(f => {
                const [lng, lat] = f.geometry.coordinates;
                const inBounds = lng >= minLng && lng <= maxLng && lat >= minLat && lat <= maxLat;
                const name = (f.properties.name || '').toLowerCase();
                const location = (f.properties.name_location || '').toLowerCase();
                const matchesQuery = name.includes(query) || location.includes(query);
                return inBounds && matchesQuery;
            }).slice(0, 10);

            if (matches.length === 0) {
                searchResults.style.display = 'none';
                return;
            }

            searchResults.innerHTML = matches.map(f => `
                <div class="search-result-item" data-lng="${f.geometry.coordinates[0]}" data-lat="${f.geometry.coordinates[1]}">
                    <div class="result-name">${f.properties.name}</div>
                    <div class="result-address">${f.properties.name_location}</div>
                    <div class="result-phone">${f.properties.phone || ''}</div>
                </div>
            `).join('');

            searchResults.style.display = 'block';

            searchResults.querySelectorAll('.search-result-item').forEach(item => {
                item.addEventListener('click', () => {
                    const lng = parseFloat(item.dataset.lng);
                    const lat = parseFloat(item.dataset.lat);
                    zoomToKindergarten({ lng, lat });
                    searchResults.style.display = 'none';
                    searchInput.value = item.querySelector('.result-name').textContent;
                });
            });
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) searchResults.style.display = 'none';
        });

        function displayKindergartenList(pointsInIsochrone) {
            const list = document.getElementById('kindergartenList');
            const count = document.getElementById('kindergartenCount');
            count.textContent = pointsInIsochrone.length;

            if (pointsInIsochrone.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">ბაგა-ბაღები არ მოიძებნა</p>';
                return;
            }

            // ---- Sort selected kindergarten first, rest by distance ----
            if (currentSelectedKindergarten && currentSelectedKindergartenName) {
                const [selLng, selLat] = [currentSelectedKindergarten.lng, currentSelectedKindergarten.lat];
                pointsInIsochrone.sort((a, b) => {
                    if (a.properties.name === currentSelectedKindergartenName) return -1;
                    if (b.properties.name === currentSelectedKindergartenName) return 1;
                    const distA = turf.distance(turf.point([selLng, selLat]), turf.point(a.geometry.coordinates));
                    const distB = turf.distance(turf.point([selLng, selLat]), turf.point(b.geometry.coordinates));
                    return distA - distB;
                });
            }

            // ---- Render list ----
            list.innerHTML = pointsInIsochrone.map(feature => {
                const props = feature.properties;
                const isSelected = props.name === currentSelectedKindergartenName;
                let html = `<div class="kindergarten-item${isSelected ? ' selected' : ''}" 
                            data-lng="${feature.geometry.coordinates[0]}" 
                            data-lat="${feature.geometry.coordinates[1]}" 
                            data-name="${props.name || ''}">`;

                if (props.image && props.image !== 'null' && props.image !== '') {
                    html += `<img src="${props.image}" style="width:100%; height:150px; object-fit:cover; border-radius:5px; margin-bottom:10px;" onerror="this.style.display='none'">`;
                }

                html += `<h4>${props.name || 'უსახელო'}</h4>`;
                if (props.location) html += `<p>📍 ${props.location}</p>`;
                if (props.phone && props.phone !== 'null' && props.phone !== '') html += `<p>📞 ${props.phone}</p>`;
                if (props.email && props.email !== 'null' && props.email !== '') html += `<p>✉️ ${props.email}</p>`;
                if (props.facebook && props.facebook !== 'null' && props.facebook !== '') {
                    html += `<p>👥 <a href="${props.facebook}" target="_blank" style="color:#6c86cf; text-decoration:none;">Facebook</a></p>`;
                }

                html += '</div>';
                return html;
            }).join('');

            let currentHoveredFeatureName = null; // track which item is currently hovered

            // ---- Add hover & click behavior ----
            pointsInIsochrone.forEach((feature, index) => {
                const item = list.children[index];
                if (!item) return;

                const featureLngLat = feature.geometry.coordinates;
                const isSelected = feature.properties.name === currentSelectedKindergartenName;

                // Hover: animate point and show temporary route
                item.addEventListener('mouseenter', () => {
                    if (isSelected) return; // <-- skip popup if hovering selected item
                    if (!map.getLayer('isochrone-points-layer')) return;

                    // Remove previous temp route and popup only if hovering a new item
                    if (currentHoveredFeatureName && currentHoveredFeatureName !== feature.properties.name) {
                        if (map.getLayer('temp-route-line')) {
                            map.removeLayer('temp-route-line');
                            map.removeSource('temp-route');
                        }
                        const existingPopup = document.getElementById('routePopup');
                        if (existingPopup) existingPopup.remove();
                    }

                    currentHoveredFeatureName = feature.properties.name;

                    // Smooth circle animation
                    map.setPaintProperty('isochrone-points-layer', 'circle-radius', [
                        'case', ['==', ['get', 'name'], feature.properties.name], 8, 4
                    ]);
                    map.setPaintProperty('isochrone-points-layer', 'circle-color', [
                        'case', ['==', ['get', 'name'], feature.properties.name], '#f768a1', '#ae017e'
                    ]);

                    // Determine route start point:
                    let from;
                    if (userLocation) {
                        // User has pressed the geolocate button
                        from = userLocation;
                    } else if (currentSelectedKindergarten) {
                        from = [currentSelectedKindergarten.lng, currentSelectedKindergarten.lat];
                    } else {
                        return; // no valid starting point
                    }

                    // Show temporary route
                    showRoute(from, featureLngLat, resultsMode, false);
                });

                //item.addEventListener('mouseleave', () => {
                    // Reset visuals
                  //  if (!map.getLayer('isochrone-points-layer')) return;

                  //  map.setPaintProperty('isochrone-points-layer', 'circle-radius', 4);
                  //  map.setPaintProperty('isochrone-points-layer', 'circle-color', '#ae017e');

                    // Remove route & popup
                  //  if (map.getLayer('temp-route-line')) {
                  //      map.removeLayer('temp-route-line');
                  //      map.removeSource('temp-route');
                    //}
                    
                    // Remove custom popup div if it exists
                   // const existingPopup = document.getElementById('routePopup');
                   // if (existingPopup) {
                     //   existingPopup.remove();
                  //  }
                //});

                // Click: zoom, select, and show permanent route
                item.addEventListener('click', () => {
                    const lng = parseFloat(item.dataset.lng);
                    const lat = parseFloat(item.dataset.lat);
                    const name = item.dataset.name;

                    currentSelectedKindergarten = { lng, lat };
                    currentSelectedKindergartenName = name;

                    // Re-render list
                    displayKindergartenList(pointsInIsochrone);
                    zoomToKindergarten({ lng, lat });

                    // If geolocation active, use user location
                    if (userLocation) {
                        showRoute(userLocation, [lng, lat], resultsMode, true);
                    } else {
                        showRouteToSelected([lng, lat], resultsMode, true);
                    }
                });
            });
        }

        function filterPointsByIsochrone(isochronePolygon) {
            if (!kindergartenData || !kindergartenData.features) return [];
            
            const pointsInIsochrone = [];
            kindergartenData.features.forEach(feature => {
                const point = turf.point(feature.geometry.coordinates);
                try {
                    if (turf.booleanPointInPolygon(point, isochronePolygon)) {
                        pointsInIsochrone.push({
                            type: 'Feature',
                            geometry: feature.geometry,
                            properties: {
                                name: feature.properties.name || '',
                                location: feature.properties.name_location || '',
                                phone: feature.properties.phone || '',
                                email: feature.properties.email || '',
                                facebook: feature.properties.facebook || '',
                                image: feature.properties.image || ''
                            }
                        });
                    }
                } catch (err) {
                    console.error('Error checking kindergarten:', err);
                }
            });
            
            return pointsInIsochrone;
        }

        function updatePointsLayer(isochronePolygon) {
            const pointsInIsochrone = filterPointsByIsochrone(isochronePolygon);
            const geoJSON = { type: 'FeatureCollection', features: pointsInIsochrone };
            
            if (map.getSource('isochrone-points')) {
                map.getSource('isochrone-points').setData(geoJSON);
            } else {
                map.addSource('isochrone-points', { type: 'geojson', data: geoJSON });
                map.addLayer({
                    id: 'isochrone-points-layer',
                    type: 'circle',
                    source: 'isochrone-points',
                    paint: {
                        'circle-radius': 5,
                        'circle-color': '#ae017e',
                        'circle-opacity': 0.75,
                        'circle-stroke-width': 0.75,
                        'circle-stroke-color': '#ffffff',
                        'circle-radius-transition': { duration: 2000, delay: 3000 },
                        'circle-color-transition': { duration: 2000, delay: 3000 }
                    }
                });
            }
            
            displayKindergartenList(pointsInIsochrone);
            document.getElementById('kindergartenResults').style.display = 'block';
            updateAccidentsLayer(isochronePolygon);
        }

        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            const searchContainer = document.querySelector('.search-container');
            
            if (tab === 'survey') {
                document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
                document.getElementById('surveyTab').classList.add('active');
                if (map.getSource('iso')) {
                    map.getSource('iso').setData({ type: 'FeatureCollection', features: [] });
                }
                if (map.getSource('isochrone-points')) {
                    map.getSource('isochrone-points').setData({ type: 'FeatureCollection', features: [] });
                }
                if (map.getSource('isochrone-accidents')) {
                    map.getSource('isochrone-accidents').setData({ type: 'FeatureCollection', features: [] });
                }
                document.getElementById('accidentResults').style.display = 'none';
                document.getElementById('aggregateResults').style.display = 'none';
                document.getElementById('kindergartenResults').style.display = 'none';
                searchContainer.classList.remove('visible');
            } else if (tab === 'results') {
                document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
                document.getElementById('resultsTab').classList.add('active');
                searchContainer.classList.add('visible');
            }
        }
        
        function setResultsMode(mode) {
            resultsMode = mode;
            document.querySelectorAll('#resultsTab .toggle').forEach(t => t.classList.remove('active'));
            document.querySelector(`#resultsTab .toggle[data-mode="${mode}"]`).classList.add('active');
            
            if (currentSelectedKindergarten && currentTab === 'results' && currentIsochronePolygon) {
                generateKindergartenIsochroneWithMode(currentSelectedKindergarten, mode);
            }
        }

        function zoomToKindergarten(lngLat) {
            if (marker) marker.remove();
            currentSelectedKindergarten = { lng: lngLat.lng, lat: lngLat.lat };

            // Find the clicked kindergarten by coordinates and store its name
            if (kindergartenData && kindergartenData.features) {
                const selected = kindergartenData.features.find(f =>
                    f.geometry.coordinates[0] === lngLat.lng && f.geometry.coordinates[1] === lngLat.lat
                );
                currentSelectedKindergartenName = selected ? selected.properties.name : null;
            }
            
            const pulseElement = document.createElement('div');
            pulseElement.className = 'pulsating-dot';
            
            marker = new mapboxgl.Marker({ element: pulseElement, anchor: 'center' })
                .setLngLat([lngLat.lng, lngLat.lat])
                .addTo(map);

            map.flyTo({ center: [lngLat.lng, lngLat.lat], zoom: 15, speed: 1, });
            generateKindergartenIsochrone(lngLat);
        }

        function generateKindergartenIsochrone(lngLat) {
            const time = 15;
            const url = `https://api.mapbox.com/isochrone/v1/mapbox/walking/${lngLat.lng},${lngLat.lat}?contours_minutes=${time}&polygons=true&access_token=${mapboxgl.accessToken}`;

            fetch(url)
                .then(r => r.json())
                .then(data => {
                    if (!data.features || data.features.length === 0) return;

                    if (map.getSource('iso')) {
                        map.getSource('iso').setData(data);
                    } else {
                        map.addSource('iso', { type: 'geojson', data });
                        map.addLayer({
                            id: 'isoLayer',
                            type: 'fill',
                            source: 'iso',
                            paint: {
                                'fill-color': '#5a3fc0',
                                'fill-opacity': 0.3
                            }
                        });
                    }

                    const isochroneFeature = data.features[0];
                    currentIsochronePolygon = isochroneFeature;
                    
                    updatePointsLayer(isochroneFeature);

                    const bbox = turf.bbox(isochroneFeature);
                    map.fitBounds(bbox, { padding: 0, maxZoom: 19, minZoom: 12 });

                    if (marker) {
                        marker.remove();
                        const pulseElement = document.createElement('div');
                        pulseElement.className = 'pulsating-dot';
                        marker = new mapboxgl.Marker({ element: pulseElement, anchor: 'center' })
                            .setLngLat([lngLat.lng, lngLat.lat])
                            .addTo(map);
                    }

                    const aggregated = aggregateResultsInIsochrone(isochroneFeature);
                    displayAggregatedResults(aggregated);
                    document.getElementById('aggregateResults').style.display = 'block';
                })
                .catch(err => console.error('Isochrone error:', err));
        }

        function generateKindergartenIsochroneWithMode(lngLat, mode) {
            const time = document.getElementById('timeResults').value;
            console.log('Generating isochrone with time:', time, 'mode:', mode);
            const url = `https://api.mapbox.com/isochrone/v1/mapbox/${mode}/${lngLat.lng},${lngLat.lat}?contours_minutes=${time}&polygons=true&access_token=${mapboxgl.accessToken}`;

            fetch(url)
                .then(r => r.json())
                .then(data => {
                    console.log('Isochrone response:', data);
                    if (!data.features || data.features.length === 0) {
                        console.error('No features in isochrone response');
                        return;
                    }

                    if (map.getSource('iso')) {
                        map.getSource('iso').setData(data);
                    }

                    const isochroneFeature = data.features[0];
                    currentIsochronePolygon = isochroneFeature;
                    
                    updatePointsLayer(isochroneFeature);

                    const bbox = turf.bbox(isochroneFeature);
                    map.fitBounds(bbox, { padding: 0, maxZoom: 20, minZoom: 12 });

                    const aggregated = aggregateResultsInIsochrone(isochroneFeature);
                    displayAggregatedResults(aggregated);
                    document.getElementById('aggregateResults').style.display = 'block';
                })
                .catch(err => console.error('Isochrone error:', err));
        }
        
        function aggregateResultsInIsochrone(isochronePolygon) {
            const aggregated = { total: 0, age: {}, gender: {}, vote: {}, economy: {}, priority: {}, grids: [] };
            surveyDataGeoJSON.features.forEach(feature => {
                const point = turf.point(feature.geometry.coordinates);
                try {
                    if (turf.booleanPointInPolygon(point, isochronePolygon)) {
                        const props = feature.properties;
                        aggregated.grids.push({ name: props.gridName, count: props.responses.length });
                        props.responses.forEach(response => {
                            aggregated.total++;
                            if (response.age) aggregated.age[response.age] = (aggregated.age[response.age] || 0) + 1;
                            if (response.gender) aggregated.gender[response.gender] = (aggregated.gender[response.gender] || 0) + 1;
                            if (response.vote) aggregated.vote[response.vote] = (aggregated.vote[response.vote] || 0) + 1;
                            if (response.economy) aggregated.economy[response.economy] = (aggregated.economy[response.economy] || 0) + 1;
                            if (response.priority) aggregated.priority[response.priority] = (aggregated.priority[response.priority] || 0) + 1;
                        });
                    }
                } catch (err) {
                    console.error('Error checking feature:', err);
                }
            });
            return aggregated;
        }
        
        function displayAggregatedResults(data) {
            if (data.total === 0) {
                document.getElementById('aggregateContent').innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">ამ არეალში მონაცემები არ არის</p>';
                return;
            }
            
            const voteLabels = { qocebi: 'ქართული ოცნება', lelo: 'ლელო', gakharia: 'გახარია', boycott: 'ბოიკოტი', undecided: 'გადაუწყვეტელი' };
            const priorityLabels = { economy: 'ეკონომიკა', democracy: 'დემოკრატია', eu: 'ევროინტეგრაცია', security: 'უსაფრთხოება', education: 'განათლება' };
            const economyLabels = { very_good: 'ძალიან კარგი', good: 'კარგი', neutral: 'საშუალო', bad: 'ცუდი', very_bad: 'ძალიან ცუდი' };
            const genderLabels = { male: 'კაცი', female: 'ქალი', other: 'სხვა' };
            
            Object.values(chartInstances).forEach(chart => { try { chart.destroy(); } catch(e) {} });
            chartInstances = {};
            
            let html = `<div class="aggregate-stat"><strong>სულ პასუხი:</strong> ${data.total}</div>`;
            
            if (Object.keys(data.gender).length > 0) html += `<div class="chart-container"><h4>სქესი</h4><div class="chart-wrapper tiny"><canvas id="genderChart"></canvas></div></div>`;
            if (Object.keys(data.vote).length > 0) html += `<div class="chart-container"><h4>პარტიული გადანაწილება</h4><div class="chart-wrapper small"><canvas id="voteChart"></canvas></div></div>`;
            if (Object.keys(data.priority).length > 0) html += `<div class="chart-container"><h4>პრიორიტეტები</h4><div class="chart-wrapper small"><canvas id="priorityChart"></canvas></div></div>`;
            if (Object.keys(data.economy).length > 0) html += `<div class="chart-container"><h4>ეკონომიკის შეფასება</h4><div class="chart-wrapper small"><canvas id="economyChart"></canvas></div></div>`;
            if (Object.keys(data.age).length > 0) html += `<div class="chart-container"><h4>ასაკი</h4><div class="chart-wrapper tiny"><canvas id="ageChart"></canvas></div></div>`;
            
            document.getElementById('aggregateContent').innerHTML = html;
            setTimeout(() => createCharts(data, voteLabels, priorityLabels, economyLabels, genderLabels), 100);
        }
        
        function createCharts(data, voteLabels, priorityLabels, economyLabels, genderLabels) {
            if (typeof Chart === 'undefined') return;
            
            const chartConfig = {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { display: false },
                    tooltip: { backgroundColor: 'rgba(0, 0, 0, 0.8)', padding: 8, titleFont: { size: 11 }, bodyFont: { size: 10 }, displayColors: false }
                }
            };
            
            if (Object.keys(data.gender).length > 0) {
                const ctx = document.getElementById('genderChart')?.getContext('2d');
                if (ctx) {
                    chartInstances.gender = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(data.gender).map(k => genderLabels[k] || k),
                            datasets: [{ data: Object.values(data.gender), backgroundColor: ['#6c86cf', '#a8b9e3', '#e3f0fc'], borderWidth: 0 }]
                        },
                        options: { ...chartConfig, cutout: '75%' }
                    });
                }
            }
            
            if (Object.keys(data.vote).length > 0) {
                const ctx = document.getElementById('voteChart')?.getContext('2d');
                if (ctx) {
                    const sorted = Object.entries(data.vote).sort((a, b) => b[1] - a[1]);
                    chartInstances.vote = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sorted.map(([k]) => voteLabels[k] || k),
                            datasets: [{ data: sorted.map(([,v]) => v), backgroundColor: '#6c86cf', borderRadius: 2, borderWidth: 0 }]
                        },
                        options: { indexAxis: 'y', ...chartConfig, scales: { x: { display: false, beginAtZero: true }, y: { grid: { display: false }, ticks: { font: { size: 10 }, color: '#666' } } } }
                    });
                }
            }
            
            if (Object.keys(data.priority).length > 0) {
                const ctx = document.getElementById('priorityChart')?.getContext('2d');
                if (ctx) {
                    const sorted = Object.entries(data.priority).sort((a, b) => b[1] - a[1]);
                    chartInstances.priority = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sorted.map(([k]) => priorityLabels[k] || k),
                            datasets: [{ data: sorted.map(([,v]) => v), backgroundColor: '#a8b9e3', borderRadius: 2, borderWidth: 0 }]
                        },
                        options: { indexAxis: 'y', ...chartConfig, scales: { x: { display: false, beginAtZero: true }, y: { grid: { display: false }, ticks: { font: { size: 10 }, color: '#666' } } } }
                    });
                }
            }
            
            if (Object.keys(data.economy).length > 0) {
                const ctx = document.getElementById('economyChart')?.getContext('2d');
                if (ctx) {
                    const order = ['very_good', 'good', 'neutral', 'bad', 'very_bad'];
                    const sorted = order.filter(k => data.economy[k]).map(k => [k, data.economy[k]]);
                    const colors = ['#4caf50', '#8bc34a', '#ffc107', '#ff9800', '#f44336'];
                    chartInstances.economy = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sorted.map(([k]) => economyLabels[k] || k),
                            datasets: [{ data: sorted.map(([,v]) => v), backgroundColor: colors.slice(0, sorted.length), borderRadius: 2, borderWidth: 0 }]
                        },
                        options: { indexAxis: 'y', ...chartConfig, scales: { x: { display: false, beginAtZero: true }, y: { grid: { display: false }, ticks: { font: { size: 10 }, color: '#666' } } } }
                    });
                }
            }
            
            if (Object.keys(data.age).length > 0) {
                const ctx = document.getElementById('ageChart')?.getContext('2d');
                if (ctx) {
                    const sorted = Object.entries(data.age).sort((a, b) => a[0].localeCompare(b[0]));
                    chartInstances.age = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sorted.map(([k]) => k),
                            datasets: [{ data: sorted.map(([,v]) => v), backgroundColor: '#c5d1f0', borderRadius: 2, borderWidth: 0 }]
                        },
                        options: { ...chartConfig, scales: { y: { display: false, beginAtZero: true }, x: { grid: { display: false }, ticks: { font: { size: 10 }, color: '#666' } } } }
                    });
                }
            }
        }
        
        const modal = document.getElementById('modal');
        document.querySelector('.close').onclick = () => modal.style.display = 'none';
        window.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
        
        document.getElementById('surveyForm').onsubmit = async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const cellId = currentFeature.properties.cellId;
            const center = getCellCenter(cellId);
            const gridName = currentFeature.properties.gridName;
            
            const response = {
                timestamp: new Date().toISOString(),
                gridName, cellId,
                lat: center[1],
                lng: center[0],
                age: formData.get('age'),
                gender: formData.get('gender'),
                vote: formData.get('vote'),
                economy: formData.get('economy'),
                priority: formData.get('priority')
            };
            
            let feature = surveyDataGeoJSON.features.find(f => f.properties.gridName === gridName);
            if (!feature) {
                feature = {
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: center },
                    properties: { gridName, cellId, responses: [] }
                };
                surveyDataGeoJSON.features.push(feature);
            }
            
            feature.properties.responses.push({
                timestamp: response.timestamp,
                age: response.age,
                gender: response.gender,
                vote: response.vote,
                economy: response.economy,
                priority: response.priority
            });
            
            if (map.getSource('survey-data')) map.getSource('survey-data').setData(surveyDataGeoJSON);
            
            try {
                await fetch(APPS_SCRIPT_URL, { method: 'POST', body: JSON.stringify(response) });
            } catch (err) {
                console.error('Failed to send to Google Sheets:', err);
            }
            
            alert('მადლობა! თქვენი პასუხი შენახულია.');
            modal.style.display = 'none';
            e.target.reset();
            updateGridLayer();
        };
        
        function updateGridLayer() {
            const bounds = map.getBounds();
            const features = [];
            const existingGrids = {};
        
            surveyDataGeoJSON.features.forEach(f => {
                existingGrids[f.properties.cellId] = { gridName: f.properties.gridName, count: f.properties.responses.length };
            });
        
            for (let lng = Math.floor(bounds.getWest() / GRID_SIZE_LNG) * GRID_SIZE_LNG; lng <= bounds.getEast(); lng += GRID_SIZE_LNG) {
                for (let lat = Math.floor(bounds.getSouth() / GRID_SIZE_LAT) * GRID_SIZE_LAT; lat <= bounds.getNorth(); lat += GRID_SIZE_LAT) {
                    const cellId = getCellId(lng, lat);
                    const existing = existingGrids[cellId];
                    const count = existing ? existing.count : 0;
                    const gridName = existing ? existing.gridName : generateThreeWordName(cellId);
        
                    if (count > 0 || map.getZoom() > 10.5) {
                        features.push({
                            type: 'Feature',
                            properties: { cellId, gridName, count, hasData: count > 0 },
                            geometry: { type: 'Polygon', coordinates: [getCellBounds(cellId)] }
                        });
                    }
                }
            }
        
            if (map.getSource('grid')) map.getSource('grid').setData({ type: 'FeatureCollection', features });
        }
        
        map.on('click', (e) => {
            if (currentTab === 'survey') {
                const features = map.queryRenderedFeatures(e.point, { layers: ['grid-layer'] });
                if (features.length > 0) {
                    const props = features[0].properties;
                    const gridName = props.gridName || generateThreeWordName(props.cellId);
                    currentFeature = { properties: { cellId: props.cellId, gridName, count: props.count } };
                    const center = getCellCenter(props.cellId);
                    document.getElementById('cellInfo').innerHTML = 
                        `<div class="three-word-name">${gridName}</div>` +
                        `<strong>Grid ID:</strong> ${props.cellId}<br>` +
                        `<strong>ცენტრი:</strong> ${center[1].toFixed(6)}, ${center[0].toFixed(6)}<br>` +
                        `<strong>ზომა:</strong> ~500m x 500m<br>` +
                        `<strong>არსებული პასუხები:</strong> ${props.count}`;
                    modal.style.display = 'block';
                }
            }
        });
        
        map.on('load', () => {
            map.addSource('grid', { type: 'geojson', data: fixedGrid });
            
            map.addLayer({
                id: 'grid-layer',
                type: 'fill',
                source: 'grid',
                paint: {
                    'fill-color': ['case', ['>', ['get', 'count'], 0], ['interpolate', ['linear'], ['get', 'count'], 1, '#e3f0fc', 5, '#6c86cf', 10, '#4a6bb0'], '#ffffff'],
                    'fill-opacity': 0.05
                },
                minzoom: 11
            });
            
            map.addLayer({
                id: 'grid-outline',
                type: 'line',
                source: 'grid',
                paint: {
                    'line-color': '#6c86cf',
                    'line-opacity': 0.25,
                    'line-width': ['interpolate', ['linear'], ['zoom'], 10, 0.5, 12, 0.75, 14, 1, 16, 3]
                }
            });
            
            map.addSource('survey-data', { type: 'geojson', data: surveyDataGeoJSON });
            map.addSource('kindergartens', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            
            map.addLayer({
                id: 'kindergartens-layer',
                type: 'circle',
                source: 'kindergartens',
                paint: {
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 10, 1, 14, 2, 16, 4],
                    'circle-color': '#810f7c',
                    'circle-opacity': 0.8,
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#ffffff'
                },
                layout: { 'visibility': 'none' }
            });
            
            map.addLayer({
                id: 'kindergartens-labels',
                type: 'symbol',
                source: 'kindergartens',
                layout: {
                    'text-field': ['get', 'name'],
                    'text-font': ['Noto Sans Georgian Regular', 'Arial Unicode MS Regular'],
                    'text-size': 11,
                    'text-offset': [0, 1.5],
                    'text-anchor': 'top',
                    'visibility': 'none'
                },
                paint: {
                    'text-color': '#810f7c',
                    'text-halo-color': '#ffffff',
                    'text-halo-width': 2
                },
                minzoom: 13
            });
            
            map.addSource('iso', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            map.addLayer({ id: 'iso-layer', type: 'fill', source: 'iso', paint: { 'fill-color': '#6c86cf', 'fill-opacity': 0.2 } });
            map.addLayer({ id: 'iso-outline', type: 'line', source: 'iso', paint: { 'line-color': '#6c86cf', 'line-width': 2 } });

            map.addSource('car-accidents', { 
                type: 'geojson', 
                data: { type: 'FeatureCollection', features: [] } 
            });

            loadCarAccidentData();
            loadKindergartenData();
            loadDataFromSheets();
            updateGridLayer();
        });

        map.on('moveend', updateGridLayer);
        map.on('zoomend', updateGridLayer);
        
        document.getElementById('timeResults').addEventListener('change', () => {
            console.log('Time changed to:', document.getElementById('timeResults').value);
            if (currentSelectedKindergarten && currentTab === 'results') {
                generateKindergartenIsochroneWithMode(currentSelectedKindergarten, resultsMode);
            }
        });
    </script>
</body>
</html>